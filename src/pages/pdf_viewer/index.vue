<template>
   <GPT_Page>
      <!-- Â∑¶‰æßÈ¢ÑËßàÂå∫Âüü -->
      <div class="h-[100vh] w-[calc(100vw-3.5rem)] flex">
         <div class="w-1/2 h-full overflow-auto">
            <!-- Loading state -->
            <div v-if="fileLoading" class="h-full flex items-center justify-center">
               <div class="flex flex-col items-center gap-2">
                  <Loader2 class="h-8 w-8 animate-spin" />
                  <p class="text-sm text-muted-foreground">Loading {{ fileType }}...</p>
               </div>
            </div>
            
            <!-- Error state -->
            <div v-else-if="fileError" class="h-full flex items-center justify-center">
               <div class="flex flex-col items-center gap-2">
                  <AlertCircle class="h-8 w-8 text-destructive" />
                  <p class="text-sm text-destructive">Failed to load {{ fileType }}</p>
                  <Button variant="outline" size="sm" @click="downloadFile">
                     Retry
                  </Button>
               </div>
            </div>

            <!-- DOCXÊñá‰ª∂È¢ÑËßà -->
            <div v-else-if="fileType === 'DOCX'" class="h-full">
               <vue-office-docx 
                  :src="docxContent" 
                  style="height: 100%;" 
                  @rendered="onDocxRendered"
                  @error="onDocxError"
                  v-if="docxContent"
               />
            </div>

            <!-- PPTXÊñá‰ª∂È¢ÑËßà -->
            <div v-else-if="fileType === 'PPTX'" class="h-full">
               <vue-office-pptx 
                  :src="pptxContent" 
                  style="height: 100%;" 
                  @rendered="onPptxRendered"
                  @error="onPptxError"
                  v-if="pptxContent"
               />
            </div>

            <!-- PDBÊñá‰ª∂È¢ÑËßà -->
            <div v-else-if="fileType === 'PDB'" class="h-full">
               <!-- PDB MolstarÁªÑ‰ª∂Âç†‰ΩçÁ¨¶ - Áî®Êà∑‰ºöÊõøÊç¢Ëøô‰∏™ -->
               <div class="h-full w-full flex items-center justify-center">
                  <protein3d_molstar ref="protein3d_molstar_ref" :refer_pdb_string="pdbContent" v-if="pdbContent" />
               </div>
            </div>

            <!-- FASTAÊñá‰ª∂È¢ÑËßà -->
            <div v-else-if="fileType === 'FASTA'" class="h-full">
               <div class="bg-white h-full flex flex-col">
                  <div class="bg-gray-50 px-4 py-3 border-b rounded-t-lg">
                     <h3 class="text-lg font-semibold flex items-center gap-2">
                        <span class="text-blue-600">üß¨</span>
                        FASTA Sequence
                     </h3>
                  </div>
                  <div class="p-4 flex-1 overflow-auto">
                     <div v-if="fastaContent.trim()" class="font-mono text-sm">
                        <div v-html="formatFastaSequence(fastaContent)"></div>
                     </div>
                     <div v-else class="text-gray-400 text-sm">
                        FASTAÂ∫èÂàóÂä†ËΩΩ‰∏≠...
                     </div>
                  </div>
                  
                  <!-- Â∫èÂàóÈ¢úËâ≤ËØ¥Êòé -->
                  <div v-if="fastaContent.trim()" class="mt-4 mx-4 mb-4 p-3 bg-blue-50 rounded-md">
                     <h4 class="text-sm font-semibold mb-2">
                        {{ getCurrentSequenceType() === 'dna' ? 'DNA/RNAÁ¢±Âü∫È¢úËâ≤ËØ¥ÊòéÔºö' : 'Ê∞®Âü∫ÈÖ∏È¢úËâ≤ËØ¥ÊòéÔºö' }}
                     </h4>
                     
                     <!-- DNA/RNAÈ¢úËâ≤ËØ¥Êòé -->
                     <div v-if="getCurrentSequenceType() === 'dna'" class="grid grid-cols-2 md:grid-cols-5 gap-2 text-xs">
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #FF6B6B;"></span>
                           <span>ËÖ∫ÂòåÂë§ (A)</span>
                        </div>
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #4ECDC4;"></span>
                           <span>ËÉ∏ËÖ∫ÂòßÂï∂ (T)</span>
                        </div>
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #45B7D1;"></span>
                           <span>È∏üÂòåÂë§ (G)</span>
                        </div>
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #FFA07A;"></span>
                           <span>ËÉûÂòßÂï∂ (C)</span>
                        </div>
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #98D8C8;"></span>
                           <span>Â∞øÂòßÂï∂ (U)</span>
                        </div>
                     </div>
                     
                     <!-- ËõãÁôΩË¥®È¢úËâ≤ËØ¥Êòé -->
                     <div v-else class="grid grid-cols-2 md:grid-cols-5 gap-2 text-xs">
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #FF6B6B;"></span>
                           <span>ÁñèÊ∞¥ÊÄß (A,V,I,L,M,F,W,Y)</span>
                        </div>
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #4ECDC4;"></span>
                           <span>ÊûÅÊÄß (S,T,N,Q)</span>
                        </div>
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #45B7D1;"></span>
                           <span>Á¢±ÊÄß (K,R,H)</span>
                        </div>
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #FFA07A;"></span>
                           <span>ÈÖ∏ÊÄß (D,E)</span>
                        </div>
                        <div class="flex items-center gap-1">
                           <span class="w-3 h-3 rounded-full" style="background-color: #98D8C8;"></span>
                           <span>ÁâπÊÆä (G,P,C)</span>
                        </div>
                     </div>
                  </div>
               </div>
            </div>

            <!-- ÂõæÁâáÈ¢ÑËßà -->
            <div v-else-if="fileType === 'IMAGE'" class="h-full flex items-center justify-center">
               <img :src="imageUrl || ''" class="max-w-full max-h-full object-contain" alt="Preview" />
            </div>

            <!-- PDFÈ¢ÑËßà -->
            <div v-else-if="fileType === 'PDF'" class="h-full relative">
               <!-- PDFÁªÑ‰ª∂ -->
               <VuePdfEmbed 
                 :source="pdfDoc" 
                 v-if="pdfDoc"
                 ref="pdfEmbedRef"
                 class="pdf-embed-container"
                 @rendered="onPdfRendered"
               />
               
               <!-- Bbox overlayÂÆπÂô® -->
               <div 
                 v-if="showBboxOverlay"
                 id="bbox-overlay-container"
                 class="absolute inset-0 z-10"
                 style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;"
               >
                 <!-- Ê∏≤ÊüìÊâÄÊúâÂèØËßÅÁöÑbbox -->
                 <div
                   v-for="bbox in visibleBboxes"
                   :key="`bbox-${bbox.molecule_key}-${bbox.page_idx}`"
                   class="absolute border-2 transition-all duration-300 rounded cursor-pointer hover:shadow-lg"
                   :class="bbox.highlighted ? 'border-red-500 bg-red-100 bg-opacity-40 shadow-lg' : 'border-blue-500 bg-blue-100 bg-opacity-20 hover:bg-blue-200 hover:bg-opacity-30'"
                   @click="onBboxClick(bbox)"
                   :style="{
                     left: `${bbox.screenX}px`,
                     top: `${bbox.screenY}px`,
                     width: `${bbox.screenWidth}px`,
                     height: `${bbox.screenHeight}px`,
                     zIndex: bbox.highlighted ? 100 : 50,
                     transform: bbox.highlighted ? 'scale(1.02)' : 'scale(1)',
                     borderWidth: bbox.highlighted ? '3px' : '2px',
                     pointerEvents: 'auto'
                   }"
                   :title="`ÂàÜÂ≠ê: ${bbox.molecule_key}, È°µÈù¢: ${bbox.page_idx + 1}`"
                 >
                   <!-- È´ò‰∫ÆÊó∂ÊòæÁ§∫ÂàÜÂ≠êkey -->
                   <div 
                     v-if="bbox.highlighted" 
                     class="absolute -top-6 left-0 bg-red-500 text-white text-xs px-2 py-1 rounded whitespace-nowrap pointer-events-none"
                   >
                     {{ bbox.molecule_key.substring(0, 8) }}...
                   </div>
                 </div>
               </div>
            </div>

                         <!-- TXTÊñá‰ª∂È¢ÑËßà -->
             <div v-else-if="fileType === 'TXT'" class="h-full overflow-auto">
                <div class="bg-white h-full flex flex-col">
                   <div class="bg-gray-50 px-4 py-3 border-b rounded-t-lg">
                      <h3 class="text-lg font-semibold flex items-center gap-2">
                         <span class="text-blue-600">üìÑ</span>
                         TXT Êñá‰ª∂ÂÜÖÂÆπ
                      </h3>
                   </div>
                   <div class="p-4 flex-1 overflow-auto">
                      <div v-if="txtContent.trim()" class="font-mono text-sm whitespace-pre-wrap break-words">
                         {{ txtContent }}
                      </div>
                      <div v-else class="text-gray-400 text-sm">
                         TXTÂÜÖÂÆπÂä†ËΩΩ‰∏≠...
                      </div>
                   </div>
                </div>
             </div>
         </div>

         <!-- ÂàÜÈöîÁ∫ø -->
         <div class="w-1 h-full bg-gray-200 cursor-col-resize"></div>

         <!-- Âè≥‰æßmarkdownËß£ÊûêÁªìÊûú -->
         <div class="w-1/2 h-full overflow-auto flex flex-col">
            <!-- Tab ÂØºËà™Ê†è -->
            <div class="flex-shrink-0 border-b">
               <div class="flex justify-between items-center p-3">
                  <div class="flex">
                     <button 
                        @click="activeTab = 'original'"
                        :class="[
                           'px-4 py-2 text-sm font-medium rounded-t-lg transition-colors',
                           activeTab === 'original' 
                              ? 'bg-blue-50 text-blue-600 border-b-2 border-blue-600' 
                              : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'
                        ]"
                     >
                        ÂéüÊñáËß£Êûê
                     </button>
                     <button 
                        @click="activeTab = 'molecular'"
                        :class="[
                           'px-4 py-2 text-sm font-medium rounded-t-lg transition-colors ml-1',
                           activeTab === 'molecular' 
                              ? 'bg-blue-50 text-blue-600 border-b-2 border-blue-600' 
                              : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'
                        ]"
                     >
                        ÂàÜÂ≠êË°®Ê†º
                     </button>
                  </div>
                  
                  <!-- ‰ªÖÂú®ÂéüÊñátabÊó∂ÊòæÁ§∫ÁöÑÊåâÈíÆ -->
                  <div v-if="activeTab === 'original'" class="flex gap-2">
                     <Button variant="default" size="sm" @click="translate_markdown" class="text-xs px-3 py-1">
                        {{ show_ori_markdown ? 'ÁøªËØë' : 'ÂéüÊñá' }}
                     </Button>
                     <Button variant="outline" size="sm" @click="copyMarkdown" class="text-xs px-3 py-1">
                        Â§çÂà∂
                     </Button>
                     <Button variant="outline" size="sm" @click="exportDocx" :disabled="exportingDocx" class="text-xs px-3 py-1">
                        {{ exportingDocx ? 'ÂØºÂá∫‰∏≠...' : 'ÂØºÂá∫' }}
                     </Button>
                  </div>
               </div>
            </div>
            
            <!-- Tab ÂÜÖÂÆπÂå∫Âüü -->
            <div class="flex-1 overflow-auto">
               <!-- ÂéüÊñá Tab -->
               <div v-show="activeTab === 'original'">
                  <div v-if="markdownLoading" class="h-full flex items-center justify-center">
                     <div class="flex flex-col items-center gap-2">
                        <Loader2 class="h-8 w-8 animate-spin" />
                        <p class="text-sm text-muted-foreground">Loading content...</p>
                     </div>
                  </div>
                  <div v-else-if="markdownError" class="h-full flex items-center justify-center">
                     <div class="flex flex-col items-center gap-2">
                        <AlertCircle class="h-8 w-8 text-destructive" />
                        <p class="text-sm text-destructive">Failed to load content</p>
                        <Button variant="outline" size="sm" @click="get_markdown">
                           Retry
                        </Button>
                     </div>
                  </div>
                  <markdown-viewer 
                     v-else 
                     :content="markdown_content" 
                     :docId="docId" 
                     :isTranslateMode="!show_ori_markdown"
                     ref="markdown_ref"
                  />
               </div>
               
               <!-- ÂàÜÂ≠êË°®Ê†º Tab -->
               <div v-show="activeTab === 'molecular'">
                  <MoleculeTable 
                     :content="markdown_content" 
                     :docId="docId" 
                     @molecules-processed="onMoleculesProcessed"
                     @molecule-selected="onMoleculeSelected"
                     ref="molecule_table_ref"
                  />
               </div>
            </div>
         </div>
      </div>
   </GPT_Page>
</template>

<script setup lang="ts">
import { useRoute } from 'vue-router'
import GPT_Page from '@/components/Layout/GPT_Page.vue'
import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue'
import { useToast } from '@/components/ui/toast'
import VuePdfEmbed, { useVuePdfEmbed } from 'vue-pdf-embed'
import MarkdownViewer from './components/markdown_viewer.vue'
import MoleculeTable from './components/molecule_table.vue'
// @ts-ignore
import { get_doc_markdown_api, open_knowledge_api } from '@/api/common.js'
import { Loader2, AlertCircle } from 'lucide-vue-next'
import { Button } from '@/components/ui/button'
import { useStore } from '@/stores/index.js'
import { preview_pdf_from_s3, arrayBufferToBase64, decryptFile } from '@/utils/common.js'
// @ts-ignore
import protein3d_molstar from '@/components/molecule/protein3d_molstar.vue'

// ÂØºÂÖ•vue-officeÁªÑ‰ª∂
import VueOfficeDocx from '@vue-office/docx'
import VueOfficePptx from '@vue-office/pptx'
// ÂØºÂÖ•Ê†∑Âºè
import '@vue-office/docx/lib/index.css'

// ÂØºÂÖ•Êñá‰ª∂‰øùÂ≠òÂ∫ì
// @ts-ignore
import { saveAs } from 'file-saver'

type FileType = 'PDF' | 'IMAGE' | 'FASTA' | 'PDB' | 'DOCX' | 'PPTX' | 'TXT'

const route = useRoute()
const docId = route.query.docId as string
const if_img = route.query?.if_img
const download_url = route.query?.download_url as string
const download_key = route.query?.download_key as string

// Êñá‰ª∂Á±ªÂûãÊ£ÄÊµã
const fileType = computed<FileType>(() => {
  if (if_img) return 'IMAGE'
  if (!download_key) return 'PDF'
  
  const key = download_key.toLowerCase()
  if (key.includes('.pdb') || key.includes('pdb')) return 'PDB'
  if (key.includes('.fasta') || key.includes('.fst') || key.includes('fasta')) return 'FASTA'
  if (key.includes('.png') || key.includes('.jpg') || key.includes('.jpeg') || key.includes('image')) return 'IMAGE'
  if (key.includes('.docx') || key.includes('docx')) return 'DOCX'
  if (key.includes('.pptx') || key.includes('pptx')) return 'PPTX'
  if (key.includes('.txt') || key.includes('txt')) return 'TXT'
  return 'PDF'
})

// Áä∂ÊÄÅÁÆ°ÁêÜ
const fileLoading = ref(true)
const fileError = ref(false)
const markdownLoading = ref(true)
const markdownError = ref(false)
const show_ori_markdown = ref(true)
const first_translate = ref(true)
const exportingDocx = ref(false)
const activeTab = ref('original') // Êñ∞Â¢ûÔºöÂΩìÂâçÊøÄÊ¥ªÁöÑtab
const processedMolecules = ref<string[]>([]) // Â∑≤Â§ÑÁêÜÁöÑÂàÜÂ≠êkeys

// bboxÁõ∏ÂÖ≥Áä∂ÊÄÅ
const currentHighlightedMolecule = ref<string | null>(null)
const allMoleculeBboxes = ref<Map<string, {
  page_idx: number
  bbox: number[]
}>>(new Map())
const pdfEmbedRef = ref<InstanceType<typeof VuePdfEmbed> | null>(null)
const showBboxOverlay = ref(false)
const visibleBboxes = ref<Array<{
  molecule_key: string
  page_idx: number
  screenX: number
  screenY: number
  screenWidth: number
  screenHeight: number
  highlighted: boolean
}>>([])
const pdfDoc = ref<any>(null)
const imageUrl = ref<string | null>(null)
const fastaContent = ref<string>('')
const pdbContent = ref<string>('')
const docxContent = ref<any>(null)
const pptxContent = ref<any>(null)
const txtContent = ref<string>('')
const protein3d_molstar_ref = ref<InstanceType<typeof protein3d_molstar> | null>(null)

// ÂÖ∂‰ªñ
const markdown_content = ref('## ËøôÈáåÊòØMarkdownËß£ÊûêÂô®\n\nÊñáÊ°£‰ªçÂú®Ëß£Êûê‰∏≠ÔºåËØ∑Âú®Ëß£ÊûêÂÆåÊàêÂêéÊü•ÁúãÁªìÊûú')
const markdown_ref = ref<InstanceType<typeof MarkdownViewer> | null>(null)
const molecule_table_ref = ref<InstanceType<typeof MoleculeTable> | null>(null)
const key = ref('XAEhg51aKKSMHgFUSQJr6hEkWv5gCYJ8j7kfQixCV8c=')
const { toast } = useToast()
const store = useStore()

store.isSidebarOpen = false

// Ê∞®Âü∫ÈÖ∏È¢úËâ≤Êò†Â∞Ñ
const aminoAcidColors = {
  // ÁñèÊ∞¥ÊÄßÊ∞®Âü∫ÈÖ∏ - Á∫¢Ëâ≤Á≥ª
  'A': '#FF6B6B', 'V': '#FF6B6B', 'I': '#FF6B6B', 'L': '#FF6B6B', 
  'M': '#FF6B6B', 'F': '#FF6B6B', 'W': '#FF6B6B', 'Y': '#FF6B6B',
  // ÊûÅÊÄßÊ∞®Âü∫ÈÖ∏ - ÈùíËâ≤Á≥ª
  'S': '#4ECDC4', 'T': '#4ECDC4', 'N': '#4ECDC4', 'Q': '#4ECDC4',
  // Á¢±ÊÄßÊ∞®Âü∫ÈÖ∏ - ËìùËâ≤Á≥ª
  'K': '#45B7D1', 'R': '#45B7D1', 'H': '#45B7D1',
  // ÈÖ∏ÊÄßÊ∞®Âü∫ÈÖ∏ - Ê©ôËâ≤Á≥ª
  'D': '#FFA07A', 'E': '#FFA07A',
  // ÁâπÊÆäÊ∞®Âü∫ÈÖ∏ - ÁªøËâ≤Á≥ª
  'G': '#98D8C8', 'P': '#98D8C8', 'C': '#98D8C8'
}

// DNAÁ¢±Âü∫È¢úËâ≤Êò†Â∞Ñ
const dnaBaseColors = {
  'A': '#FF6B6B', // ËÖ∫ÂòåÂë§ - Á∫¢Ëâ≤
  'T': '#4ECDC4', // ËÉ∏ËÖ∫ÂòßÂï∂ - ÈùíËâ≤
  'G': '#45B7D1', // È∏üÂòåÂë§ - ËìùËâ≤
  'C': '#FFA07A', // ËÉûÂòßÂï∂ - Ê©ôËâ≤
  'U': '#98D8C8'  // Â∞øÂòßÂï∂ (RNA) - ÁªøËâ≤
}

// Ê£ÄÊµãÂ∫èÂàóÁ±ªÂûã
const detectSequenceType = (sequence: string) => {
  const cleanSeq = sequence.replace(/[^A-Za-z]/g, '').toUpperCase()
  if (cleanSeq.length === 0) return 'unknown'
  
  // ÁªüËÆ°ÂêÑÁßçÂ≠óÁ¨¶ÁöÑÂá∫Áé∞Ê¨°Êï∞
  const dnaChars = cleanSeq.split('').filter(char => 'ATGCU'.includes(char)).length
  const proteinChars = cleanSeq.split('').filter(char => 'ACDEFGHIKLMNPQRSTVWY'.includes(char)).length
  
  // Â¶ÇÊûúÂ∫èÂàóÂè™ÂåÖÂê´DNA/RNAÂ≠óÁ¨¶Ôºå‰∏îËá≥Â∞ëÊúâ‰∏Ä‰∏™TÊàñUÔºåÂàôËÆ§‰∏∫ÊòØDNA/RNA
  if (dnaChars === cleanSeq.length && (cleanSeq.includes('T') || cleanSeq.includes('U'))) {
    return 'dna'
  }
  
  // Â¶ÇÊûúÂ∫èÂàóÂåÖÂê´ËõãÁôΩË¥®ÁâπÊúâÁöÑÊ∞®Âü∫ÈÖ∏ÔºåÂàôËÆ§‰∏∫ÊòØËõãÁôΩË¥®
  if (cleanSeq.split('').some(char => 'DEFHIKLMNPQRSVWY'.includes(char))) {
    return 'protein'
  }
  
  // ÂÖ∂‰ªñÊÉÖÂÜµÈªòËÆ§‰∏∫ËõãÁôΩË¥®
  return 'protein'
}

// Ê†ºÂºèÂåñFASTAÂ∫èÂàóÔºåÊ∑ªÂä†È¢úËâ≤
const formatFastaSequence = (fastaText: string) => {
  if (!fastaText.trim()) return ''
  
  const lines = fastaText.trim().split('\n')
  let currentSequence = ''
  let sequenceType = 'unknown'
  
  const formattedLines = lines.map(line => {
    const trimmedLine = line.trim()
    
    // Â¶ÇÊûúÊòØÂ∫èÂàóÂêçÁß∞Ë°åÔºà‰ª•>ÂºÄÂ§¥Ôºâ
    if (trimmedLine.startsWith('>')) {
      return `<div class="font-bold text-purple-600 mb-1">${trimmedLine}</div>`
    }
    
    // Â¶ÇÊûúÊòØÂ∫èÂàóÂÜÖÂÆπË°å
    if (trimmedLine.length > 0) {
      // Á¥ØÁßØÂ∫èÂàóÂÜÖÂÆπÁî®‰∫éÁ±ªÂûãÊ£ÄÊµã
      currentSequence += trimmedLine
      sequenceType = detectSequenceType(currentSequence)
      
      const coloredSequence = trimmedLine.split('').map(char => {
        const upperChar = char.toUpperCase()
        let color = ''
        
        // Ê†πÊçÆÂ∫èÂàóÁ±ªÂûãÈÄâÊã©È¢úËâ≤Êò†Â∞Ñ
        if (sequenceType === 'dna') {
          color = dnaBaseColors[upperChar as keyof typeof dnaBaseColors] || ''
        } else {
          color = aminoAcidColors[upperChar as keyof typeof aminoAcidColors] || ''
        }
        
        if (color) {
          return `<span style="color: ${color}; font-weight: bold; background-color: ${color}20; padding: 1px 2px; border-radius: 2px;">${char}</span>`
        } else if (char.match(/[A-Za-z]/)) {
          // Êú™Áü•Â≠óÁ¨¶ÔºåÁî®ÁÅ∞Ëâ≤ÊòæÁ§∫
          return `<span style="color: #999; background-color: #f0f0f0; padding: 1px 2px; border-radius: 2px;">${char}</span>`
        } else {
          // ÈùûÂ≠óÊØçÂ≠óÁ¨¶ÔºàÂ¶ÇÁ©∫Ê†º„ÄÅÊï∞Â≠óÁ≠âÔºâ
          return char
        }
      }).join('')
      
      return `<div class="mb-1 leading-relaxed">${coloredSequence}</div>`
    }
    
    return ''
  }).filter(line => line !== '')
  
  return formattedLines.join('')
}

// Ëé∑ÂèñÂΩìÂâçÂ∫èÂàóÁ±ªÂûãÁî®‰∫éUIÊòæÁ§∫
const getCurrentSequenceType = () => {
  if (!fastaContent.value.trim()) return 'unknown'
  const sequenceLines = fastaContent.value.trim().split('\n').filter(line => !line.startsWith('>'))
  const sequence = sequenceLines.join('')
  return detectSequenceType(sequence)
}

// DOCX Â§ÑÁêÜÂõûË∞É
const onDocxRendered = () => {
  console.log('DOCX rendered successfully')
}

const onDocxError = (error: any) => {
  console.error('DOCX render error:', error)
  toast({
    title: "Error",
    description: "DOCX Êñá‰ª∂Ê∏≤ÊüìÂ§±Ë¥•",
    variant: "destructive"
  })
}

// PPTX Â§ÑÁêÜÂõûË∞É
const onPptxRendered = () => {
  console.log('PPTX rendered successfully')
}

const onPptxError = (error: any) => {
  console.error('PPTX render error:', error)
  toast({
    title: "Error",
    description: "PPTX Êñá‰ª∂Ê∏≤ÊüìÂ§±Ë¥•",
    variant: "destructive"
  })
}

const translate_markdown = () => {
  show_ori_markdown.value = !show_ori_markdown.value
  if (first_translate.value && markdown_ref.value) {
    first_translate.value = false
    markdown_ref.value.split_content()
    markdown_ref.value.translate_content_continue()
  }
}

const copyMarkdown = async () => {
  if (!markdown_content.value) {
    toast({
      title: "ÊèêÁ§∫",
      description: "Ê≤°ÊúâÂèØÂ§çÂà∂ÁöÑÂÜÖÂÆπ",
      variant: "default"
    })
    return
  }
  
  try {
    await navigator.clipboard.writeText(markdown_content.value)
    toast({
      title: "ÊàêÂäü",
      description: "MarkdownÂÜÖÂÆπÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø",
      variant: "default"
    })
  } catch (error) {
    toast({
      title: "ÈîôËØØ",
      description: "Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÈáçËØï",
      variant: "destructive"
    })
  }
}

const exportDocx = async () => {
  if (!markdown_ref.value) {
    toast({
      title: "ÈîôËØØ",
      description: "ÊñáÊ°£ÂÜÖÂÆπÊú™Âä†ËΩΩ",
      variant: "destructive"
    })
    return
  }
  
  exportingDocx.value = true
  
  try {
    // Ëé∑ÂèñÂΩìÂâçÊòæÁ§∫ÁöÑmarkdownÂÜÖÂÆπÔºàÂèØËÉΩÊòØÁøªËØëÂêéÁöÑÔºâ
    const currentContent = markdown_ref.value.getCurrentMarkdownContent()
    
    if (!currentContent) {
      toast({
        title: "ÈîôËØØ",
        description: "ÊñáÊ°£ÂÜÖÂÆπ‰∏∫Á©∫",
        variant: "destructive"
      })
      return
    }

    toast({
      title: "Ê≠£Âú®ÂØºÂá∫...",
      description: "Ê≠£Âú®ÁîüÊàêDOCXÊñá‰ª∂ÔºåËØ∑Á®çÁ≠â"
    })

    // ‰ΩøÁî®ÂâçÁ´ØÁîüÊàêDOCX
    const { generateDocx } = await import('@/utils/docxGenerator')
    await generateDocx(currentContent)
    
    toast({
      title: "ÊàêÂäü",
      description: "DOCXÊñáÊ°£Â∑≤ÂØºÂá∫",
      variant: "default"
    })
  } catch (error) {
    console.error('ÂØºÂá∫DOCXÂ§±Ë¥•:', error)
    toast({
      title: "ÈîôËØØ",
      description: error instanceof Error ? error.message : "ÂØºÂá∫Â§±Ë¥•ÔºåËØ∑ÈáçËØï",
      variant: "destructive"
    })
  } finally {
    exportingDocx.value = false
  }
}

const get_markdown = () => {
  markdownLoading.value = true
  markdownError.value = false
  
  get_doc_markdown_api(docId)
    .then((res: any) => {
      if (res.data?.data?.markdown) {
        markdown_content.value = res.data.data.markdown
      }
    })
    .catch(() => {
      markdownError.value = true
      toast({
        title: "Error",
        description: "Markdown Ëé∑ÂèñÂ§±Ë¥•",
        variant: "destructive"
      })
    })
    .finally(() => {
      markdownLoading.value = false
    })
}

const downloadFile = async () => {
  fileLoading.value = true
  fileError.value = false

  try {
    if (download_url) {
      if (fileType.value === 'PDF') {
        // Âè™ÊúâPDFÈúÄË¶Å‰∏ãËΩΩÂπ∂Ëß£ÂØÜ
        const arrayBuffer = await preview_pdf_from_s3(download_url, download_key)
        const encryptedBytes = new Uint8Array(arrayBuffer)
        const iv = encryptedBytes.slice(0, 16)
        const ciphertext = encryptedBytes.slice(16)
        const ivBase64 = arrayBufferToBase64(iv.buffer)
        const ciphertextBase64 = arrayBufferToBase64(ciphertext.buffer)
        const decrypted = await decryptFile(ciphertextBase64, key.value, ivBase64)
        console.log('decrypted', decrypted)
        await handleDecryptedContent(decrypted)
      } else {
        // ÂÖ∂‰ªñÊñá‰ª∂Á±ªÂûãÁõ¥Êé•‰∏ãËΩΩÔºå‰∏çËß£ÂØÜ
        const arrayBuffer = await preview_pdf_from_s3(download_url, download_key)
        await handleRawContent(arrayBuffer)
      }
    } else {
      // ‰ΩøÁî®API‰∏ãËΩΩ
      const res = await open_knowledge_api(docId)
      await handleApiResponse(res)
    }
  } catch (error) {
    fileError.value = true
    toast({
      title: "Error",
      description: "Êñá‰ª∂‰∏ãËΩΩÂ§±Ë¥•",
      variant: "destructive"
    })
  } finally {
    fileLoading.value = false
  }
}

const handleDecryptedContent = async (decrypted: any) => {
  switch (fileType.value) {
    case 'PDF':
      const { doc } = useVuePdfEmbed({ source: decrypted })
      pdfDoc.value = doc
      break
  }
}

const handleRawContent = async (arrayBuffer: ArrayBuffer) => {
  switch (fileType.value) {
    case 'IMAGE':
      const imageBlob = new Blob([arrayBuffer], { type: "image/png" })
      imageUrl.value = window.URL.createObjectURL(imageBlob)
      break
    case 'FASTA':
      fastaContent.value = new TextDecoder().decode(arrayBuffer)
      break
    case 'PDB':
      pdbContent.value = new TextDecoder().decode(arrayBuffer)
      setTimeout(() => {
        if (protein3d_molstar_ref.value) {
          protein3d_molstar_ref.value.draw_refer()
        }
      }, 1000)
      break
    case 'DOCX':
      // DOCX Êñá‰ª∂ÂèØ‰ª•Áõ¥Êé•‰º†ÈÄí ArrayBuffer
      docxContent.value = arrayBuffer
      break
    case 'PPTX':
      // PPTX Êñá‰ª∂ÂèØ‰ª•Áõ¥Êé•‰º†ÈÄí ArrayBuffer
      pptxContent.value = arrayBuffer
      break
    case 'TXT':
      txtContent.value = new TextDecoder().decode(arrayBuffer)
      break
  }
}

const handleApiResponse = async (res: any) => {
  switch (fileType.value) {
    case 'IMAGE':
      const imageBlob = new Blob([res.data], { type: "image/jpeg" })
      imageUrl.value = window.URL.createObjectURL(imageBlob)
      break
    case 'PDF':
      const pdfBlob = new Blob([res.data], { type: "application/pdf" })
      const pdfFile = new File([pdfBlob], 'pdf.pdf', { type: pdfBlob.type })
      const pdfUrl = window.URL.createObjectURL(pdfFile)
      const { doc } = useVuePdfEmbed({ source: pdfUrl })
      pdfDoc.value = doc
      break
    case 'FASTA':
      // ÂÅáËÆæAPIËøîÂõûÊñáÊú¨ÂÜÖÂÆπ
      fastaContent.value = new TextDecoder().decode(res.data)
      break
    case 'PDB':
      // ÂÅáËÆæAPIËøîÂõûÊñáÊú¨ÂÜÖÂÆπ
      pdbContent.value = new TextDecoder().decode(res.data)
      break
    case 'DOCX':
      // DOCX Êñá‰ª∂ÂèØ‰ª•Áõ¥Êé•‰º†ÈÄí ArrayBuffer
      docxContent.value = res.data
      break
    case 'PPTX':
      // PPTX Êñá‰ª∂ÂèØ‰ª•Áõ¥Êé•‰º†ÈÄí ArrayBuffer
      pptxContent.value = res.data
      break
    case 'TXT':
      txtContent.value = new TextDecoder().decode(res.data)
      break
  }
}

// ÂàÜÂ≠êÂ§ÑÁêÜÂÆåÊàêÂõûË∞É
const onMoleculesProcessed = (moleculeKeys: string[]) => {
  processedMolecules.value = moleculeKeys
  
  // Êî∂ÈõÜÊâÄÊúâÂàÜÂ≠êÁöÑbbox‰ø°ÊÅØ
  if (molecule_table_ref.value?.molecules) {
    allMoleculeBboxes.value.clear()
    molecule_table_ref.value.molecules.forEach((molecule: any) => {
      if (molecule.page_idx !== undefined && molecule.bbox) {
        allMoleculeBboxes.value.set(molecule.key, {
          page_idx: molecule.page_idx,
          bbox: molecule.bbox
        })
      }
    })
    showBboxOverlay.value = true
    updateVisibleBboxes()
  }
}

// ÂàÜÂ≠êÈÄâÊã©ÂõûË∞É
const onMoleculeSelected = (selection: {
  key: string
  page_idx?: number
  bbox?: number[]
  molecule: any
}) => {
  currentHighlightedMolecule.value = selection.key
  
  if (selection.page_idx !== undefined && selection.bbox) {
    // Ë∑≥ËΩ¨Âà∞ÂØπÂ∫îÈ°µÈù¢
    navigateToPage(selection.page_idx)
    
    // Êõ¥Êñ∞bboxÊòæÁ§∫
    updateVisibleBboxes()
  } else {
    console.log('Êù°‰ª∂‰∏çÊª°Ë∂≥:', {
      'page_idxÂ≠òÂú®': selection.page_idx !== undefined,
      'bboxÂ≠òÂú®': !!selection.bbox,
      'pdfDocÂ≠òÂú®': !!pdfDoc.value
    })
  }
}

// bboxÁÇπÂáªÂ§ÑÁêÜ
const onBboxClick = (bbox: {
  molecule_key: string
  page_idx: number
  screenX: number
  screenY: number
  screenWidth: number
  screenHeight: number
  highlighted: boolean
}) => {
  
  // ÂàáÊç¢Âà∞ÂàÜÂ≠êË°®Ê†ºtab
  activeTab.value = 'molecular'
  
  // È´ò‰∫ÆÂΩìÂâçÂàÜÂ≠ê
  currentHighlightedMolecule.value = bbox.molecule_key
  
  // ÈÄöÁü•ÂàÜÂ≠êË°®Ê†ºÁªÑ‰ª∂Ë∑≥ËΩ¨Âà∞ÂØπÂ∫îÊù°ÁõÆ
  if (molecule_table_ref.value) {
    molecule_table_ref.value.scrollToMolecule(bbox.molecule_key)
  }
  
  // Êõ¥Êñ∞bboxÊòæÁ§∫
  updateVisibleBboxes()
}

// PDFÊ∏≤ÊüìÂÆåÊàêÂõûË∞É
const onPdfRendered = () => {
  showBboxOverlay.value = true
  updateVisibleBboxes()
}

// Ë∑≥ËΩ¨Âà∞ÊåáÂÆöÈ°µÈù¢
const navigateToPage = (pageIndex: number) => {

  // ÂÖàËé∑ÂèñPDFÂÆπÂô®ÔºåÁÑ∂ÂêéÊâæÂà∞ÂÆÉÁöÑÊªöÂä®Áà∂ÂÖÉÁ¥†
  let pdfContainer = document.querySelector('.pdf-embed-container')
  if (!pdfContainer) {
    pdfContainer = document.querySelector('.vue-pdf-embed')
  }
  if (!pdfContainer && pdfEmbedRef.value) {
    pdfContainer = pdfEmbedRef.value.$el
  }
  
  if (!pdfContainer) {
    console.warn('Êú™ÊâæÂà∞PDFÂÆπÂô®')
    return
  }
  // ÊâæÂà∞Â∑¶‰æßÈ¢ÑËßàÂå∫ÂüüÔºàPDFÂÆπÂô®ÁöÑÊªöÂä®Áà∂ÂÖÉÁ¥†Ôºâ
  const leftPanel = pdfContainer.closest('.overflow-auto')
  if (!leftPanel) {
    console.warn('Êú™ÊâæÂà∞ÊªöÂä®ÂÆπÂô®')
    return
  }
  
  // Ëé∑ÂèñÊâÄÊúâÈ°µÈù¢ÂÖÉÁ¥†
  const allPages = pdfContainer.querySelectorAll('[class*="page"], [id*="page"], canvas, .vue-pdf-embed > div')

  if (pageIndex >= allPages.length) {
    console.warn(`È°µÈù¢Á¥¢Âºï ${pageIndex} Ë∂ÖÂá∫ËåÉÂõ¥ÔºåÊÄªÈ°µÈù¢Êï∞: ${allPages.length}`)
    return
  }
  
  // ËÆ°ÁÆóÁ¥ØÁßØÈ´òÂ∫¶Âà∞ÁõÆÊ†áÈ°µÈù¢
  let scrollToPosition = 0
  for (let i = 0; i < pageIndex; i++) {
    if (allPages[i]) {
      const pageRect = allPages[i].getBoundingClientRect()
      scrollToPosition += pageRect.height
    }
  }
  
  // Âπ≥ÊªëÊªöÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
  leftPanel.scrollTo({
    top: scrollToPosition,
    behavior: 'smooth'
  })
}

// ËÆ°ÁÆóÂπ∂Êõ¥Êñ∞ÂèØËßÅÁöÑbbox
const updateVisibleBboxes = () => {
  if (!pdfEmbedRef.value || !showBboxOverlay.value) {
    visibleBboxes.value = []
    return
  }

  const newVisibleBboxes: typeof visibleBboxes.value = []
  
  // Ëé∑ÂèñPDFÂÆπÂô® - ÂÖàÂ∞ùËØïÂá†ÁßçÂèØËÉΩÁöÑÈÄâÊã©Âô®
  let pdfContainer = document.querySelector('.pdf-embed-container')
  if (!pdfContainer) {
    pdfContainer = document.querySelector('.vue-pdf-embed')
  }
  if (!pdfContainer) {
    pdfContainer = pdfEmbedRef.value?.$el
  }
  if (!pdfContainer) {
    visibleBboxes.value = []
    return
  }

    // Ëé∑ÂèñÊâÄÊúâÈ°µÈù¢ÂÖÉÁ¥†
  const allPages = pdfContainer.querySelectorAll('.vue-pdf-embed > div')
  // ÈÅçÂéÜÊâÄÊúâbboxÊï∞ÊçÆ
  allMoleculeBboxes.value.forEach((bboxInfo, moleculeKey) => {
    const { page_idx, bbox } = bboxInfo
    // Áõ¥Êé•ÈÄöËøáÁ¥¢ÂºïËé∑ÂèñÈ°µÈù¢ÂÖÉÁ¥†
    const pageElement = allPages[page_idx]
    
    if (pageElement) {
      const pageRect = pageElement.getBoundingClientRect()
      const containerRect = pdfContainer.getBoundingClientRect()
      
      // Ê£ÄÊü•bboxÊï∞ÊçÆÊ†ºÂºè
      if (!Array.isArray(bbox) || bbox.length < 4) {
        console.warn(`ÂàÜÂ≠ê ${moleculeKey} ÁöÑbboxÊï∞ÊçÆÊ†ºÂºè‰∏çÊ≠£Á°Æ:`, bbox)
        return
      }
      
      // È™åËØÅbboxÂÄºÁöÑÂêàÁêÜÊÄß
      const [x1, y1, x2, y2] = bbox
      if (x2 <= x1 || y2 <= y1) {
        console.warn(`ÂàÜÂ≠ê ${moleculeKey} ÁöÑbboxÊï∞ÊçÆ‰∏çÂêàÁêÜ:`, { x1, y1, x2, y2 })
        return
      }
      
      // ËÆ°ÁÆóbboxÂú®PDFÂÆπÂô®ÂÜÖÁöÑ‰ΩçÁΩÆ
      // bboxÊ†ºÂºèÊòØ [x1, y1, x2, y2]ÔºåÈúÄË¶ÅËΩ¨Êç¢‰∏∫ x, y, width, height
      const bboxX = x1
      const bboxY = y1
      const bboxWidth = x2 - x1
      const bboxHeight = y2 - y1
      
      // ËÆ°ÁÆóÈ°µÈù¢ÂÅèÁßªÔºöÁ¥ØÁßØÂâçÈù¢ÊâÄÊúâÈ°µÈù¢ÁöÑÈ´òÂ∫¶
      let pageOffsetY = 0
      for (let i = 0; i < page_idx; i++) {
        if (allPages[i]) {
          const prevPageRect = allPages[i].getBoundingClientRect()
          pageOffsetY += prevPageRect.height
        }
      }
      
      // XÂÅèÁßªÈÄöÂ∏∏ÊòØÈ°µÈù¢Áõ∏ÂØπ‰∫éÂÆπÂô®ÁöÑÊ∞¥Âπ≥ÂÅèÁßª
      const pageOffsetX = pageRect.left - containerRect.left
      // ËÆ°ÁÆóbboxÂú®È°µÈù¢ÂÜÖÁöÑÂÉèÁ¥†‰ΩçÁΩÆ
      const bboxPixelX = bboxX * pageRect.width
      const bboxPixelY = bboxY * pageRect.height
      const bboxPixelWidth = bboxWidth * pageRect.width
      const bboxPixelHeight = bboxHeight * pageRect.height
      
      // ÊúÄÁªà‰ΩçÁΩÆ = È°µÈù¢ÂÅèÁßª + bboxÂú®È°µÈù¢ÂÜÖÁöÑ‰ΩçÁΩÆ
      const finalX = pageOffsetX + bboxPixelX
      const finalY = pageOffsetY + bboxPixelY

      newVisibleBboxes.push({
        molecule_key: moleculeKey,
        page_idx,
        screenX: finalX,
        screenY: finalY,
        screenWidth: bboxPixelWidth,
        screenHeight: bboxPixelHeight,
        highlighted: moleculeKey === currentHighlightedMolecule.value
      })
    }
  })
  
  visibleBboxes.value = newVisibleBboxes
}

// ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
onMounted(() => {
  // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñ
  window.addEventListener('resize', updateVisibleBboxes)
  
  // ÁõëÂê¨PDFÂÆπÂô®ÊªöÂä® - ‰ΩøÁî®Âª∂ËøüÁ°Æ‰øùPDFÂ∑≤Ê∏≤Êüì
  setTimeout(() => {
    let pdfContainer = document.querySelector('.pdf-embed-container')
    if (!pdfContainer) {
      pdfContainer = document.querySelector('.vue-pdf-embed')
    }
    if (!pdfContainer && pdfEmbedRef.value) {
      pdfContainer = pdfEmbedRef.value.$el
    }
    
    if (pdfContainer) {
      pdfContainer.addEventListener('scroll', updateVisibleBboxes)
      
      // ‰πüÁõëÂê¨Â∑¶‰æßÈ¢ÑËßàÂå∫ÂüüÁöÑÊªöÂä®
      const leftPanel = pdfContainer.closest('.overflow-auto')
      if (leftPanel) {
        leftPanel.addEventListener('scroll', updateVisibleBboxes)
      }
    }
  }, 2000) // Âª∂Ëøü2ÁßíÁ°Æ‰øùPDFÂ∑≤ÂÆåÂÖ®Âä†ËΩΩ
})

onUnmounted(() => {
  // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
  window.removeEventListener('resize', updateVisibleBboxes)
  
  // Ê∏ÖÁêÜPDFÂÆπÂô®ÁõëÂê¨Âô®
  let pdfContainer = document.querySelector('.pdf-embed-container')
  if (!pdfContainer) {
    pdfContainer = document.querySelector('.vue-pdf-embed')
  }
  if (!pdfContainer && pdfEmbedRef.value) {
    pdfContainer = pdfEmbedRef.value.$el
  }
  
  if (pdfContainer) {
    pdfContainer.removeEventListener('scroll', updateVisibleBboxes)
    
    const leftPanel = pdfContainer.closest('.overflow-auto')
    if (leftPanel) {
      leftPanel.removeEventListener('scroll', updateVisibleBboxes)
    }
  }
})

// ÂàùÂßãÂåñ
get_markdown()
downloadFile()
</script>

<route lang="yaml">
   meta:
     layout: blank
 </route>